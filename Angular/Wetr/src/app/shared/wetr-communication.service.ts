/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.10.0 (NJsonSchema v9.13.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export module WetrCommunication {
  export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

  @Injectable({
    providedIn: 'root'
  })
  export class CommunitiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl ? baseUrl : "http://localhost:55233";
    }

    getAll(): Observable<Community[] | null> {
      let url_ = this.baseUrl + "/api/communities";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetAll(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAll(<any>response_);
          } catch (e) {
            return <Observable<Community[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<Community[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Community[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(Community.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<Community[] | null>(<any>null);
    }

    getByName(name: string | null): Observable<Community[] | null> {
      let url_ = this.baseUrl + "/api/communities/name?";
      if (name === undefined)
        throw new Error("The parameter 'name' must be defined.");
      else
        url_ += "name=" + encodeURIComponent("" + name) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetByName(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetByName(<any>response_);
          } catch (e) {
            return <Observable<Community[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<Community[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetByName(response: HttpResponseBase): Observable<Community[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(Community.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<Community[] | null>(<any>null);
    }

    getStations(q: string | null | undefined): Observable<Community[] | null> {
      let url_ = this.baseUrl + "/api/communities/stations?";
      if (q !== undefined)
        url_ += "q=" + encodeURIComponent("" + q) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetStations(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetStations(<any>response_);
          } catch (e) {
            return <Observable<Community[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<Community[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetStations(response: HttpResponseBase): Observable<Community[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(Community.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<Community[] | null>(<any>null);
    }
  }

  @Injectable({
    providedIn: 'root'
  })
  export class MeasurementsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl ? baseUrl : "http://localhost:55233";
    }

    insert(measurement: Measurement | null): Observable<boolean> {
      let url_ = this.baseUrl + "/api/measurements";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(measurement);

      let options_ : any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processInsert(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInsert(<any>response_);
          } catch (e) {
            return <Observable<boolean>><any>_observableThrow(e);
          }
        } else
          return <Observable<boolean>><any>_observableThrow(response_);
      }));
    }

    protected processInsert(response: HttpResponseBase): Observable<boolean> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<boolean>(<any>null);
    }

    getMeasurementsForStation(startDateTime: string | null, endDateTime: string | null, queryMode: number, stationId: number): Observable<Measurement[] | null> {
      let url_ = this.baseUrl + "/api/measurements?";
      if (startDateTime === undefined)
        throw new Error("The parameter 'startDateTime' must be defined.");
      else
        url_ += "startDateTime=" + encodeURIComponent("" + startDateTime) + "&";
      if (endDateTime === undefined)
        throw new Error("The parameter 'endDateTime' must be defined.");
      else
        url_ += "endDateTime=" + encodeURIComponent("" + endDateTime) + "&";
      if (queryMode === undefined || queryMode === null)
        throw new Error("The parameter 'queryMode' must be defined and cannot be null.");
      else
        url_ += "queryMode=" + encodeURIComponent("" + queryMode) + "&";
      if (stationId === undefined || stationId === null)
        throw new Error("The parameter 'stationId' must be defined and cannot be null.");
      else
        url_ += "stationId=" + encodeURIComponent("" + stationId) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetMeasurementsForStation(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetMeasurementsForStation(<any>response_);
          } catch (e) {
            return <Observable<Measurement[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<Measurement[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetMeasurementsForStation(response: HttpResponseBase): Observable<Measurement[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(Measurement.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<Measurement[] | null>(<any>null);
    }

    getAllUnits(): Observable<Unit[] | null> {
      let url_ = this.baseUrl + "/api/measurements/unit";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetAllUnits(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAllUnits(<any>response_);
          } catch (e) {
            return <Observable<Unit[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<Unit[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetAllUnits(response: HttpResponseBase): Observable<Unit[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(Unit.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<Unit[] | null>(<any>null);
    }

    getLastMeasurementsForStation(queryMode: number, stationId: number, limit: number | undefined): Observable<Measurement[] | null> {
      let url_ = this.baseUrl + "/api/measurements/last?";
      if (queryMode === undefined || queryMode === null)
        throw new Error("The parameter 'queryMode' must be defined and cannot be null.");
      else
        url_ += "queryMode=" + encodeURIComponent("" + queryMode) + "&";
      if (stationId === undefined || stationId === null)
        throw new Error("The parameter 'stationId' must be defined and cannot be null.");
      else
        url_ += "stationId=" + encodeURIComponent("" + stationId) + "&";
      if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
      else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetLastMeasurementsForStation(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLastMeasurementsForStation(<any>response_);
          } catch (e) {
            return <Observable<Measurement[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<Measurement[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetLastMeasurementsForStation(response: HttpResponseBase): Observable<Measurement[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(Measurement.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<Measurement[] | null>(<any>null);
    }

    getMeasurementsSum(startDateTime: string | null, endDateTime: string | null, queryMode: number, groupByMode: number, stationId: number | null | undefined): Observable<MeasurementAnalytic[] | null> {
      let url_ = this.baseUrl + "/api/measurements/sum?";
      if (startDateTime === undefined)
        throw new Error("The parameter 'startDateTime' must be defined.");
      else
        url_ += "startDateTime=" + encodeURIComponent("" + startDateTime) + "&";
      if (endDateTime === undefined)
        throw new Error("The parameter 'endDateTime' must be defined.");
      else
        url_ += "endDateTime=" + encodeURIComponent("" + endDateTime) + "&";
      if (queryMode === undefined || queryMode === null)
        throw new Error("The parameter 'queryMode' must be defined and cannot be null.");
      else
        url_ += "queryMode=" + encodeURIComponent("" + queryMode) + "&";
      if (groupByMode === undefined || groupByMode === null)
        throw new Error("The parameter 'groupByMode' must be defined and cannot be null.");
      else
        url_ += "groupByMode=" + encodeURIComponent("" + groupByMode) + "&";
      if (stationId !== undefined)
        url_ += "stationId=" + encodeURIComponent("" + stationId) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetMeasurementsSum(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetMeasurementsSum(<any>response_);
          } catch (e) {
            return <Observable<MeasurementAnalytic[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<MeasurementAnalytic[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetMeasurementsSum(response: HttpResponseBase): Observable<MeasurementAnalytic[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(MeasurementAnalytic.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<MeasurementAnalytic[] | null>(<any>null);
    }

    getMeasurementsMin(startDateTime: string | null, endDateTime: string | null, queryMode: number, groupByMode: number, stationId: number | null | undefined): Observable<MeasurementAnalytic[] | null> {
      let url_ = this.baseUrl + "/api/measurements/min?";
      if (startDateTime === undefined)
        throw new Error("The parameter 'startDateTime' must be defined.");
      else
        url_ += "startDateTime=" + encodeURIComponent("" + startDateTime) + "&";
      if (endDateTime === undefined)
        throw new Error("The parameter 'endDateTime' must be defined.");
      else
        url_ += "endDateTime=" + encodeURIComponent("" + endDateTime) + "&";
      if (queryMode === undefined || queryMode === null)
        throw new Error("The parameter 'queryMode' must be defined and cannot be null.");
      else
        url_ += "queryMode=" + encodeURIComponent("" + queryMode) + "&";
      if (groupByMode === undefined || groupByMode === null)
        throw new Error("The parameter 'groupByMode' must be defined and cannot be null.");
      else
        url_ += "groupByMode=" + encodeURIComponent("" + groupByMode) + "&";
      if (stationId !== undefined)
        url_ += "stationId=" + encodeURIComponent("" + stationId) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetMeasurementsMin(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetMeasurementsMin(<any>response_);
          } catch (e) {
            return <Observable<MeasurementAnalytic[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<MeasurementAnalytic[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetMeasurementsMin(response: HttpResponseBase): Observable<MeasurementAnalytic[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(MeasurementAnalytic.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<MeasurementAnalytic[] | null>(<any>null);
    }

    getMeasurementsMax(startDateTime: string | null, endDateTime: string | null, queryMode: number, groupByMode: number, stationId: number | null | undefined): Observable<MeasurementAnalytic[] | null> {
      let url_ = this.baseUrl + "/api/measurements/max?";
      if (startDateTime === undefined)
        throw new Error("The parameter 'startDateTime' must be defined.");
      else
        url_ += "startDateTime=" + encodeURIComponent("" + startDateTime) + "&";
      if (endDateTime === undefined)
        throw new Error("The parameter 'endDateTime' must be defined.");
      else
        url_ += "endDateTime=" + encodeURIComponent("" + endDateTime) + "&";
      if (queryMode === undefined || queryMode === null)
        throw new Error("The parameter 'queryMode' must be defined and cannot be null.");
      else
        url_ += "queryMode=" + encodeURIComponent("" + queryMode) + "&";
      if (groupByMode === undefined || groupByMode === null)
        throw new Error("The parameter 'groupByMode' must be defined and cannot be null.");
      else
        url_ += "groupByMode=" + encodeURIComponent("" + groupByMode) + "&";
      if (stationId !== undefined)
        url_ += "stationId=" + encodeURIComponent("" + stationId) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetMeasurementsMax(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetMeasurementsMax(<any>response_);
          } catch (e) {
            return <Observable<MeasurementAnalytic[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<MeasurementAnalytic[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetMeasurementsMax(response: HttpResponseBase): Observable<MeasurementAnalytic[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(MeasurementAnalytic.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<MeasurementAnalytic[] | null>(<any>null);
    }

    getMeasurementsAvg(startDateTime: string | null, endDateTime: string | null, queryMode: number, groupByMode: number, stationId: number | null | undefined): Observable<MeasurementAnalytic[] | null> {
      let url_ = this.baseUrl + "/api/measurements/avg?";
      if (startDateTime === undefined)
        throw new Error("The parameter 'startDateTime' must be defined.");
      else
        url_ += "startDateTime=" + encodeURIComponent("" + startDateTime) + "&";
      if (endDateTime === undefined)
        throw new Error("The parameter 'endDateTime' must be defined.");
      else
        url_ += "endDateTime=" + encodeURIComponent("" + endDateTime) + "&";
      if (queryMode === undefined || queryMode === null)
        throw new Error("The parameter 'queryMode' must be defined and cannot be null.");
      else
        url_ += "queryMode=" + encodeURIComponent("" + queryMode) + "&";
      if (groupByMode === undefined || groupByMode === null)
        throw new Error("The parameter 'groupByMode' must be defined and cannot be null.");
      else
        url_ += "groupByMode=" + encodeURIComponent("" + groupByMode) + "&";
      if (stationId !== undefined)
        url_ += "stationId=" + encodeURIComponent("" + stationId) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetMeasurementsAvg(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetMeasurementsAvg(<any>response_);
          } catch (e) {
            return <Observable<MeasurementAnalytic[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<MeasurementAnalytic[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetMeasurementsAvg(response: HttpResponseBase): Observable<MeasurementAnalytic[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(MeasurementAnalytic.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<MeasurementAnalytic[] | null>(<any>null);
    }
  }

  @Injectable({
    providedIn: 'root'
  })
  export class MeasurementTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl ? baseUrl : "http://localhost:55233";
    }

    getAll(): Observable<MeasurementType[] | null> {
      let url_ = this.baseUrl + "/api/measurementtypes";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetAll(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAll(<any>response_);
          } catch (e) {
            return <Observable<MeasurementType[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<MeasurementType[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MeasurementType[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(MeasurementType.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<MeasurementType[] | null>(<any>null);
    }
  }

  @Injectable({
    providedIn: 'root'
  })
  export class StationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl ? baseUrl : "http://localhost:55233";
    }

    getAll(): Observable<Station[] | null> {
      let url_ = this.baseUrl + "/api/stations";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetAll(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAll(<any>response_);
          } catch (e) {
            return <Observable<Station[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<Station[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Station[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(Station.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<Station[] | null>(<any>null);
    }

    addStation(station: Station | null): Observable<boolean> {
      let url_ = this.baseUrl + "/api/stations";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(station);

      let options_ : any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processAddStation(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddStation(<any>response_);
          } catch (e) {
            return <Observable<boolean>><any>_observableThrow(e);
          }
        } else
          return <Observable<boolean>><any>_observableThrow(response_);
      }));
    }

    protected processAddStation(response: HttpResponseBase): Observable<boolean> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<boolean>(<any>null);
    }

    getAllTypes(): Observable<StationType[] | null> {
      let url_ = this.baseUrl + "/api/stations/types";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetAllTypes(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAllTypes(<any>response_);
          } catch (e) {
            return <Observable<StationType[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<StationType[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetAllTypes(response: HttpResponseBase): Observable<StationType[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(StationType.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<StationType[] | null>(<any>null);
    }

    getById(id: number): Observable<Station | null> {
      let url_ = this.baseUrl + "/api/stations/{id}";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetById(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetById(<any>response_);
          } catch (e) {
            return <Observable<Station | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<Station | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Station | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? Station.fromJS(resultData200) : <any>null;
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<Station | null>(<any>null);
    }

    updateStation(id: number, station: Station | null): Observable<boolean> {
      let url_ = this.baseUrl + "/api/stations/{id}";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(station);

      let options_ : any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processUpdateStation(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdateStation(<any>response_);
          } catch (e) {
            return <Observable<boolean>><any>_observableThrow(e);
          }
        } else
          return <Observable<boolean>><any>_observableThrow(response_);
      }));
    }

    protected processUpdateStation(response: HttpResponseBase): Observable<boolean> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<boolean>(<any>null);
    }

    deleteStation(id: number, station: Station | null): Observable<boolean> {
      let url_ = this.baseUrl + "/api/stations/{id}";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(station);

      let options_ : any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processDeleteStation(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDeleteStation(<any>response_);
          } catch (e) {
            return <Observable<boolean>><any>_observableThrow(e);
          }
        } else
          return <Observable<boolean>><any>_observableThrow(response_);
      }));
    }

    protected processDeleteStation(response: HttpResponseBase): Observable<boolean> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<boolean>(<any>null);
    }

    getByCommunityId(id: number): Observable<Station[] | null> {
      let url_ = this.baseUrl + "/api/stations/community/{id}";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetByCommunityId(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetByCommunityId(<any>response_);
          } catch (e) {
            return <Observable<Station[] | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<Station[] | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetByCommunityId(response: HttpResponseBase): Observable<Station[] | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
            result200 = [];
            for (let item of resultData200)
              result200.push(Station.fromJS(item));
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<Station[] | null>(<any>null);
    }
  }

  @Injectable({
    providedIn: 'root'
  })
  export class UsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl ? baseUrl : "http://localhost:55233";
    }

    getUserByEmail(email: string | null): Observable<User | null> {
      let url_ = this.baseUrl + "/api/users?";
      if (email === undefined)
        throw new Error("The parameter 'email' must be defined.");
      else
        url_ += "email=" + encodeURIComponent("" + email) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetUserByEmail(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetUserByEmail(<any>response_);
          } catch (e) {
            return <Observable<User | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<User | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetUserByEmail(response: HttpResponseBase): Observable<User | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? User.fromJS(resultData200) : <any>null;
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<User | null>(<any>null);
    }

    getUserById(id: number): Observable<User | null> {
      let url_ = this.baseUrl + "/api/users/id?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processGetUserById(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetUserById(<any>response_);
          } catch (e) {
            return <Observable<User | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<User | null>><any>_observableThrow(response_);
      }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<User | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? User.fromJS(resultData200) : <any>null;
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<User | null>(<any>null);
    }

    checkLogin(loginDetails: LoginDetails | null): Observable<User | null> {
      let url_ = this.baseUrl + "/api/users/login";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(loginDetails);

      let options_ : any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processCheckLogin(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCheckLogin(<any>response_);
          } catch (e) {
            return <Observable<User | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<User | null>><any>_observableThrow(response_);
      }));
    }

    protected processCheckLogin(response: HttpResponseBase): Observable<User | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? User.fromJS(resultData200) : <any>null;
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<User | null>(<any>null);
    }

    checkOAuthLogin(loginDetails: OAuthLoginDetails | null): Observable<User | null> {
      let url_ = this.baseUrl + "/api/users/login/oauth";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(loginDetails);

      let options_ : any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
        return this.processCheckOAuthLogin(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCheckOAuthLogin(<any>response_);
          } catch (e) {
            return <Observable<User | null>><any>_observableThrow(e);
          }
        } else
          return <Observable<User | null>><any>_observableThrow(response_);
      }));
    }

    protected processCheckOAuthLogin(response: HttpResponseBase): Observable<User | null> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? User.fromJS(resultData200) : <any>null;
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<User | null>(<any>null);
    }
  }

  export class Community implements ICommunity {
    id!: number;
    zipCode!: number;
    name?: string | undefined;
    districtId!: number;
    zipName?: string | undefined;

    constructor(data?: ICommunity) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.id = data["Id"];
        this.zipCode = data["ZipCode"];
        this.name = data["Name"];
        this.districtId = data["DistrictId"];
        this.zipName = data["ZipName"];
      }
    }

    static fromJS(data: any): Community {
      data = typeof data === 'object' ? data : {};
      let result = new Community();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Id"] = this.id;
      data["ZipCode"] = this.zipCode;
      data["Name"] = this.name;
      data["DistrictId"] = this.districtId;
      data["ZipName"] = this.zipName;
      return data;
    }
  }

  export interface ICommunity {
    id: number;
    zipCode: number;
    name?: string | undefined;
    districtId: number;
    zipName?: string | undefined;
  }

  export class Measurement implements IMeasurement {
    id!: number;
    value!: number;
    typeId!: number;
    measurementType?: MeasurementType | undefined;
    timestamp!: Date;
    stationId!: number;
    station?: Station | undefined;
    unitId!: number;
    unit?: Unit | undefined;

    constructor(data?: IMeasurement) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.id = data["Id"];
        this.value = data["Value"];
        this.typeId = data["TypeId"];
        this.measurementType = data["MeasurementType"] ? MeasurementType.fromJS(data["MeasurementType"]) : <any>undefined;
        this.timestamp = data["Timestamp"] ? new Date(data["Timestamp"].toString()) : <any>undefined;
        this.stationId = data["StationId"];
        this.station = data["Station"] ? Station.fromJS(data["Station"]) : <any>undefined;
        this.unitId = data["UnitId"];
        this.unit = data["Unit"] ? Unit.fromJS(data["Unit"]) : <any>undefined;
      }
    }

    static fromJS(data: any): Measurement {
      data = typeof data === 'object' ? data : {};
      let result = new Measurement();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Id"] = this.id;
      data["Value"] = this.value;
      data["TypeId"] = this.typeId;
      data["MeasurementType"] = this.measurementType ? this.measurementType.toJSON() : <any>undefined;
      data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
      data["StationId"] = this.stationId;
      data["Station"] = this.station ? this.station.toJSON() : <any>undefined;
      data["UnitId"] = this.unitId;
      data["Unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
      return data;
    }
  }

  export interface IMeasurement {
    id: number;
    value: number;
    typeId: number;
    measurementType?: MeasurementType | undefined;
    timestamp: Date;
    stationId: number;
    station?: Station | undefined;
    unitId: number;
    unit?: Unit | undefined;
  }

  export class MeasurementType implements IMeasurementType {
    id!: number;
    name?: string | undefined;

    constructor(data?: IMeasurementType) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.id = data["Id"];
        this.name = data["Name"];
      }
    }

    static fromJS(data: any): MeasurementType {
      data = typeof data === 'object' ? data : {};
      let result = new MeasurementType();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Id"] = this.id;
      data["Name"] = this.name;
      return data;
    }
  }

  export interface IMeasurementType {
    id: number;
    name?: string | undefined;
  }

  export class Station implements IStation {
    id!: number;
    name?: string | undefined;
    typeId!: number;
    stationType?: StationType | undefined;
    latitude!: number;
    longitude!: number;
    communityId!: number;
    community?: Community | undefined;
    district?: District | undefined;
    province?: Province | undefined;
    altitude!: number;
    creator!: number;
    user?: User | undefined;

    constructor(data?: IStation) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.id = data["Id"];
        this.name = data["Name"];
        this.typeId = data["TypeId"];
        this.stationType = data["StationType"] ? StationType.fromJS(data["StationType"]) : <any>undefined;
        this.latitude = data["Latitude"];
        this.longitude = data["Longitude"];
        this.communityId = data["CommunityId"];
        this.community = data["Community"] ? Community.fromJS(data["Community"]) : <any>undefined;
        this.district = data["District"] ? District.fromJS(data["District"]) : <any>undefined;
        this.province = data["Province"] ? Province.fromJS(data["Province"]) : <any>undefined;
        this.altitude = data["Altitude"];
        this.creator = data["Creator"];
        this.user = data["User"] ? User.fromJS(data["User"]) : <any>undefined;
      }
    }

    static fromJS(data: any): Station {
      data = typeof data === 'object' ? data : {};
      let result = new Station();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Id"] = this.id;
      data["Name"] = this.name;
      data["TypeId"] = this.typeId;
      data["StationType"] = this.stationType ? this.stationType.toJSON() : <any>undefined;
      data["Latitude"] = this.latitude;
      data["Longitude"] = this.longitude;
      data["CommunityId"] = this.communityId;
      data["Community"] = this.community ? this.community.toJSON() : <any>undefined;
      data["District"] = this.district ? this.district.toJSON() : <any>undefined;
      data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
      data["Altitude"] = this.altitude;
      data["Creator"] = this.creator;
      data["User"] = this.user ? this.user.toJSON() : <any>undefined;
      return data;
    }
  }

  export interface IStation {
    id: number;
    name?: string | undefined;
    typeId: number;
    stationType?: StationType | undefined;
    latitude: number;
    longitude: number;
    communityId: number;
    community?: Community | undefined;
    district?: District | undefined;
    province?: Province | undefined;
    altitude: number;
    creator: number;
    user?: User | undefined;
  }

  export class StationType implements IStationType {
    id!: number;
    manufacturer?: string | undefined;
    model?: string | undefined;

    constructor(data?: IStationType) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.id = data["Id"];
        this.manufacturer = data["Manufacturer"];
        this.model = data["Model"];
      }
    }

    static fromJS(data: any): StationType {
      data = typeof data === 'object' ? data : {};
      let result = new StationType();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Id"] = this.id;
      data["Manufacturer"] = this.manufacturer;
      data["Model"] = this.model;
      return data;
    }
  }

  export interface IStationType {
    id: number;
    manufacturer?: string | undefined;
    model?: string | undefined;
  }

  export class District implements IDistrict {
    id!: number;
    name?: string | undefined;
    provinceId!: number;

    constructor(data?: IDistrict) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.id = data["Id"];
        this.name = data["Name"];
        this.provinceId = data["ProvinceId"];
      }
    }

    static fromJS(data: any): District {
      data = typeof data === 'object' ? data : {};
      let result = new District();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Id"] = this.id;
      data["Name"] = this.name;
      data["ProvinceId"] = this.provinceId;
      return data;
    }
  }

  export interface IDistrict {
    id: number;
    name?: string | undefined;
    provinceId: number;
  }

  export class Province implements IProvince {
    id!: number;
    name?: string | undefined;

    constructor(data?: IProvince) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.id = data["Id"];
        this.name = data["Name"];
      }
    }

    static fromJS(data: any): Province {
      data = typeof data === 'object' ? data : {};
      let result = new Province();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Id"] = this.id;
      data["Name"] = this.name;
      return data;
    }
  }

  export interface IProvince {
    id: number;
    name?: string | undefined;
  }

  export class User implements IUser {
    id!: number;
    username?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth!: Date;
    communityId!: number;

    constructor(data?: IUser) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.id = data["Id"];
        this.username = data["Username"];
        this.password = data["Password"];
        this.email = data["Email"];
        this.firstName = data["FirstName"];
        this.lastName = data["LastName"];
        this.dateOfBirth = data["DateOfBirth"] ? new Date(data["DateOfBirth"].toString()) : <any>undefined;
        this.communityId = data["CommunityId"];
      }
    }

    static fromJS(data: any): User {
      data = typeof data === 'object' ? data : {};
      let result = new User();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Id"] = this.id;
      data["Username"] = this.username;
      data["Password"] = this.password;
      data["Email"] = this.email;
      data["FirstName"] = this.firstName;
      data["LastName"] = this.lastName;
      data["DateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
      data["CommunityId"] = this.communityId;
      return data;
    }
  }

  export interface IUser {
    id: number;
    username?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth: Date;
    communityId: number;
  }

  export class Unit implements IUnit {
    id!: number;
    shortName?: string | undefined;
    longName?: string | undefined;

    constructor(data?: IUnit) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.id = data["Id"];
        this.shortName = data["ShortName"];
        this.longName = data["LongName"];
      }
    }

    static fromJS(data: any): Unit {
      data = typeof data === 'object' ? data : {};
      let result = new Unit();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Id"] = this.id;
      data["ShortName"] = this.shortName;
      data["LongName"] = this.longName;
      return data;
    }
  }

  export interface IUnit {
    id: number;
    shortName?: string | undefined;
    longName?: string | undefined;
  }

  export class MeasurementAnalytic implements IMeasurementAnalytic {
    hour!: number;
    day!: number;
    week!: number;
    month!: number;
    year!: number;
    value!: number;

    constructor(data?: IMeasurementAnalytic) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.hour = data["Hour"];
        this.day = data["Day"];
        this.week = data["Week"];
        this.month = data["Month"];
        this.year = data["Year"];
        this.value = data["Value"];
      }
    }

    static fromJS(data: any): MeasurementAnalytic {
      data = typeof data === 'object' ? data : {};
      let result = new MeasurementAnalytic();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Hour"] = this.hour;
      data["Day"] = this.day;
      data["Week"] = this.week;
      data["Month"] = this.month;
      data["Year"] = this.year;
      data["Value"] = this.value;
      return data;
    }
  }

  export interface IMeasurementAnalytic {
    hour: number;
    day: number;
    week: number;
    month: number;
    year: number;
    value: number;
  }

  export class LoginDetails implements ILoginDetails {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginDetails) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.username = data["Username"];
        this.password = data["Password"];
      }
    }

    static fromJS(data: any): LoginDetails {
      data = typeof data === 'object' ? data : {};
      let result = new LoginDetails();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["Username"] = this.username;
      data["Password"] = this.password;
      return data;
    }
  }

  export interface ILoginDetails {
    username?: string | undefined;
    password?: string | undefined;
  }

  export class OAuthLoginDetails implements IOAuthLoginDetails {
    email?: string | undefined;
    family_name?: string | undefined;
    given_name?: string | undefined;

    constructor(data?: IOAuthLoginDetails) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(data?: any) {
      if (data) {
        this.email = data["email"];
        this.family_name = data["family_name"];
        this.given_name = data["given_name"];
      }
    }

    static fromJS(data: any): OAuthLoginDetails {
      data = typeof data === 'object' ? data : {};
      let result = new OAuthLoginDetails();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["email"] = this.email;
      data["family_name"] = this.family_name;
      data["given_name"] = this.given_name;
      return data;
    }
  }

  export interface IOAuthLoginDetails {
    email?: string | undefined;
    family_name?: string | undefined;
    given_name?: string | undefined;
  }

  export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
      super();

      this.message = message;
      this.status = status;
      this.response = response;
      this.headers = headers;
      this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
      return obj.isSwaggerException === true;
    }
  }

  function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
      return _observableThrow(result);
    else
      return _observableThrow(new SwaggerException(message, status, response, headers, null));
  }

  function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
      if (!blob) {
        observer.next("");
        observer.complete();
      } else {
        let reader = new FileReader();
        reader.onload = event => {
          observer.next((<any>event.target).result);
          observer.complete();
        };
        reader.readAsText(blob);
      }
    });
  }

}
